# Gemini Code Execution Skill

## Overview

The Gemini API provides a code execution tool that enables the model to generate and run Python code. The model can learn iteratively from code execution results until it arrives at a final output. You can use code execution to build applications that benefit from code-based reasoning.

Use cases include:

- **Solve equations**: Mathematical calculations and complex formulas
- **Process text**: Data transformation and text analysis
- **Specialized tasks**: Using included libraries for data science, visualization, and more

**Important**: Gemini can only execute code in **Python**. You can still ask Gemini to generate code in other languages, but the model can't use the code execution tool to run it.

## TypeScript Implementation

### Setup

Install required dependency:

```bash
pnpm install @google/genai
```

### Basic Usage

```typescript
import { GoogleGenAI } from "@google/genai";

const ai = new GoogleGenAI({});

const response = await ai.models.generateContent({
  model: "gemini-2.5-flash",
  contents: [
    "What is the sum of the first 50 prime numbers? " +
      "Generate and run code for the calculation, and make sure you get all 50.",
  ],
  config: {
    tools: [{ codeExecution: {} }],
  },
});

const parts = response?.candidates?.[0]?.content?.parts || [];
parts.forEach((part) => {
  if (part.text) {
    console.log(part.text);
  }

  if (part.executableCode && part.executableCode.code) {
    console.log(part.executableCode.code);
  }

  if (part.codeExecutionResult && part.codeExecutionResult.output) {
    console.log(part.codeExecutionResult.output);
  }
});
```

## Understanding the Response

When using code execution, the model returns several content parts:

- **text**: Inline text generated by the model (explanation)
- **executableCode**: Code generated by the model that is meant to be executed
- **codeExecutionResult**: Result of the executable code

### Response Structure

```typescript
interface ExecutableCode {
  language: string; // Always "PYTHON"
  code: string; // The Python code
}

interface CodeExecutionResult {
  outcome: "OUTCOME_OK" | "OUTCOME_FAILED" | "OUTCOME_DEADLINE_EXCEEDED";
  output: string; // Standard output from code execution
}

interface ContentPart {
  text?: string;
  executableCode?: ExecutableCode;
  codeExecutionResult?: CodeExecutionResult;
  inlineData?: {
    mimeType: string;
    data: string; // Base64 encoded
  };
}

interface CodeExecutionResponse {
  text: string;
  candidates: Array<{
    content: {
      parts: ContentPart[];
      role: string;
    };
    finishReason?: string;
  }>;
  usageMetadata?: {
    promptTokenCount: number;
    candidatesTokenCount: number;
    totalTokenCount: number;
    intermediateTokenCount?: number; // Code execution tokens
  };
}
```

### Example Output

```
Okay, I need to calculate the sum of the first 50 prime numbers. Here's how I'll
approach this:

1.  **Generate Prime Numbers:** I'll use an iterative method to find prime
    numbers. I'll start with 2 and check if each subsequent number is divisible
    by any number between 2 and its square root. If not, it's a prime.
2.  **Store Primes:** I'll store the prime numbers in a list until I have 50 of
    them.
3.  **Calculate the Sum:**  Finally, I'll sum the prime numbers in the list.

Here's the Python code to do this:

def is_prime(n):
  """Efficiently checks if a number is prime."""
  if n <= 1:
    return False
  if n <= 3:
    return True
  if n % 2 == 0 or n % 3 == 0:
    return False
  i = 5
  while i * i <= n:
    if n % i == 0 or n % (i + 2) == 0:
      return False
    i += 6
  return True

primes = []
num = 2
while len(primes) < 50:
  if is_prime(num):
    primes.append(num)
  num += 1

sum_of_primes = sum(primes)
print(f'{primes=}')
print(f'{sum_of_primes=}')

primes=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,
71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,
157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229]
sum_of_primes=5117

The sum of the first 50 prime numbers is 5117.
```

## Processing Response Parts

### Extract All Parts

```typescript
interface CodeExecutionParts {
  explanation: string[];
  code: string[];
  results: string[];
  images: Array<{
    mimeType: string;
    data: string;
  }>;
}

function extractCodeExecutionParts(
  response: CodeExecutionResponse,
): CodeExecutionParts {
  const parts = response.candidates?.[0]?.content?.parts || [];

  return {
    explanation: parts.filter((part) => part.text).map((part) => part.text!),
    code: parts
      .filter((part) => part.executableCode)
      .map((part) => part.executableCode!.code),
    results: parts
      .filter((part) => part.codeExecutionResult)
      .map((part) => part.codeExecutionResult!.output),
    images: parts
      .filter((part) => part.inlineData)
      .map((part) => ({
        mimeType: part.inlineData!.mimeType,
        data: part.inlineData!.data,
      })),
  };
}

// Usage
const parts = extractCodeExecutionParts(response);
console.log("üìù Explanation:", parts.explanation.join("\n"));
console.log("\nüíª Code:", parts.code.join("\n\n"));
console.log("\nüìä Results:", parts.results.join("\n"));
console.log(`\nüñºÔ∏è Images: ${parts.images.length} generated`);
```

### Check Execution Status

```typescript
function checkCodeExecutionStatus(response: CodeExecutionResponse): void {
  const parts = response.candidates?.[0]?.content?.parts || [];

  for (const part of parts) {
    if (part.codeExecutionResult) {
      const result = part.codeExecutionResult;

      switch (result.outcome) {
        case "OUTCOME_OK":
          console.log("‚úì Code executed successfully");
          break;
        case "OUTCOME_FAILED":
          console.error("‚úó Code execution failed");
          console.error("Output:", result.output);
          break;
        case "OUTCOME_DEADLINE_EXCEEDED":
          console.error("‚è±Ô∏è Code execution timeout (max 30 seconds)");
          break;
        default:
          console.warn("? Unknown execution outcome");
      }
    }
  }
}
```

## Use Code Execution in Chat

You can use code execution as part of a multi-turn conversation:

```typescript
import { GoogleGenAI } from "@google/genai";

const ai = new GoogleGenAI({});

const chat = ai.chats.create({
  model: "gemini-2.5-flash",
  history: [
    {
      role: "user",
      parts: [{ text: "I have a math question for you:" }],
    },
    {
      role: "model",
      parts: [
        { text: "Great! I'm ready for your math question. Please ask away." },
      ],
    },
  ],
  config: {
    tools: [{ codeExecution: {} }],
  },
});

const response = await chat.sendMessage({
  message:
    "What is the sum of the first 50 prime numbers? " +
    "Generate and run code for the calculation, and make sure you get all 50.",
});

console.log("Chat response:", response.text);
```

### Multi-Turn Code Execution

```typescript
async function interactiveCodeSession() {
  const ai = new GoogleGenAI({});

  const chat = ai.chats.create({
    model: "gemini-2.5-flash",
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  // First query
  const response1 = await chat.sendMessage({
    message: "Calculate the factorial of 10",
  });
  console.log("Response 1:", response1.text);

  // Follow-up query building on previous result
  const response2 = await chat.sendMessage({
    message:
      "Now calculate the factorial of 20 and compare it to the previous result",
  });
  console.log("Response 2:", response2.text);

  // Request visualization
  const response3 = await chat.sendMessage({
    message: "Create a bar chart comparing factorials from 1 to 10",
  });
  console.log("Response 3:", response3.text);
}
```

## Input/Output (I/O) Capabilities

Starting with **Gemini 2.0 Flash**, code execution supports file input and graph output:

- **File Input**: Upload CSV and text files, ask questions about them
- **Graph Output**: Generate Matplotlib graphs returned as inline images

### File Input Support

```typescript
import { GoogleGenAI } from "@google/genai";
import { readFileSync } from "fs";

async function analyzeCSVFile(filePath: string) {
  const ai = new GoogleGenAI({});

  // Read and encode file
  const fileData = readFileSync(filePath);
  const base64Data = fileData.toString("base64");

  const response = await ai.models.generateContent({
    model: "gemini-2.0-flash",
    contents: [
      {
        parts: [
          {
            text: "Analyze this CSV file and create a visualization of the trends",
          },
          {
            inlineData: {
              mimeType: "text/csv",
              data: base64Data,
            },
          },
        ],
      },
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  // Extract generated graphs
  const parts = response.candidates?.[0]?.content?.parts || [];
  const images = parts
    .filter((part) => part.inlineData?.mimeType.startsWith("image/"))
    .map((part) => part.inlineData!);

  console.log(`Generated ${images.length} graph(s)`);
  return { response, images };
}
```

### Using Files API

```typescript
import { GoogleGenAI } from "@google/genai";

async function analyzeUploadedFile(fileId: string) {
  const ai = new GoogleGenAI({});

  const response = await ai.models.generateContent({
    model: "gemini-2.0-flash",
    contents: [
      {
        parts: [
          {
            text: "Analyze this data and create visualizations",
          },
          {
            fileData: {
              mimeType: "text/csv",
              fileUri: `https://generativelanguage.googleapis.com/v1beta/files/${fileId}`,
            },
          },
        ],
      },
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  return response;
}
```

### Extract and Save Generated Graphs

```typescript
import { writeFileSync } from "fs";

function saveGeneratedGraphs(
  response: CodeExecutionResponse,
  outputDir: string,
): void {
  const parts = response.candidates?.[0]?.content?.parts || [];

  parts
    .filter((part) => part.inlineData?.mimeType.startsWith("image/"))
    .forEach((part, index) => {
      const imageData = part.inlineData!.data;
      const extension = part.inlineData!.mimeType.split("/")[1];
      const filename = `${outputDir}/graph_${index + 1}.${extension}`;

      writeFileSync(filename, Buffer.from(imageData, "base64"));
      console.log(`‚úì Saved graph to ${filename}`);
    });
}
```

## I/O Details and Limitations

### Technical Details

| Feature                 | Details                                                    |
| ----------------------- | ---------------------------------------------------------- |
| Maximum runtime         | 30 seconds                                                 |
| Error regeneration      | Up to 5 times if code generates an error                   |
| Maximum file input size | Limited by model token window (~1M tokens / ~2MB for text) |
| Best file types         | Text and CSV files                                         |
| Input methods           | `part.inlineData` or `part.fileData` (Files API)           |
| Output format           | Always returned as `part.inlineData`                       |

### Supported Features by Model

| Feature            | Single Turn                                         | Multimodal Live API            |
| ------------------ | --------------------------------------------------- | ------------------------------ |
| Models supported   | All Gemini 2.0 and 2.5 models                       | Only Flash experimental models |
| File input types   | .png, .jpeg, .csv, .xml, .cpp, .java, .py, .js, .ts | Same                           |
| Plotting libraries | Matplotlib, seaborn                                 | Matplotlib, seaborn            |
| Multi-tool use     | Yes (code execution + grounding only)               | Yes                            |

## Pricing and Billing

### Billing Model

There's no additional charge for enabling code execution. You're billed at the current rate of input and output tokens based on the Gemini model you're using.

**Billing breakdown:**

1. **Input tokens** (billed once):
   - User prompt
   - Original input

2. **Intermediate tokens** (billed as input tokens):
   - Generated code
   - Code execution output in code environment
   - Thinking tokens

3. **Output tokens**:
   - Code generated by the model
   - Code execution results
   - Summary generated by the model

```typescript
interface CodeExecutionUsage {
  promptTokenCount: number;
  candidatesTokenCount: number;
  totalTokenCount: number;
  intermediateTokenCount?: number; // Additional input tokens from code execution
}

function analyzeCodeExecutionCost(
  usage: CodeExecutionUsage,
  modelPricing: { inputPer1M: number; outputPer1M: number },
): void {
  const totalInputTokens =
    usage.promptTokenCount + (usage.intermediateTokenCount || 0);
  const outputTokens = usage.candidatesTokenCount;

  const inputCost = (totalInputTokens / 1_000_000) * modelPricing.inputPer1M;
  const outputCost = (outputTokens / 1_000_000) * modelPricing.outputPer1M;
  const totalCost = inputCost + outputCost;

  console.log("\nüí∞ Cost Breakdown:");
  console.log(`  Original prompt: ${usage.promptTokenCount} tokens`);
  console.log(
    `  Intermediate (code execution): ${usage.intermediateTokenCount || 0} tokens`,
  );
  console.log(
    `  Total input: ${totalInputTokens} tokens ($${inputCost.toFixed(6)})`,
  );
  console.log(`  Output: ${outputTokens} tokens ($${outputCost.toFixed(6)})`);
  console.log(
    `  Total: ${usage.totalTokenCount} tokens ($${totalCost.toFixed(6)})`,
  );
}
```

### I/O Pricing

When using code execution I/O:

**Input tokens:**

- User prompt

**Output tokens:**

- Code generated by the model
- Code execution output in the code environment
- Thinking tokens
- Summary generated by the model

## Supported Libraries

The code execution environment includes these libraries:

**Core Python Libraries:**

- `numpy` - Numerical computing
- `pandas` - Data manipulation and analysis
- `scipy` - Scientific computing
- `sympy` - Symbolic mathematics

**Visualization:**

- `matplotlib` - Plotting (only library supported for graph rendering)
- `seaborn` - Statistical data visualization

**Machine Learning:**

- `scikit-learn` - Machine learning algorithms
- `tensorflow` - Deep learning

**Data Processing:**

- `opencv-python` - Image processing
- `pillow` - Image manipulation
- `imageio` - Read/write images

**File Handling:**

- `openpyxl` - Excel files
- `xlrd` - Excel files (older format)
- `PyPDF2` - PDF files
- `python-docx` - Word documents
- `python-pptx` - PowerPoint files

**Geospatial:**

- `geopandas` - Geographic data

**Other Libraries:**

- `chess` - Chess game logic
- `reportlab` - PDF generation
- `fpdf` - PDF generation
- `lxml` - XML processing
- `jinja2` - Template engine
- `tabulate` - Pretty-print tabular data

**Complete list:** attrs, chess, contourpy, fpdf, geopandas, imageio, jinja2, joblib, jsonschema, jsonschema-specifications, lxml, matplotlib, mpmath, numpy, opencv-python, openpyxl, packaging, pandas, pillow, protobuf, pylatex, pyparsing, PyPDF2, python-dateutil, python-docx, python-pptx, reportlab, scikit-learn, scipy, seaborn, six, striprtf, sympy, tabulate, tensorflow, toolz, xlrd

**Note**: You cannot install your own libraries. Only matplotlib is supported for graph rendering.

## Supported Tool Combinations

Code execution can be combined with **Grounding with Google Search** for more complex use cases:

```typescript
import { GoogleGenAI } from "@google/genai";

async function analyzeTrendsWithData(topic: string) {
  const ai = new GoogleGenAI({});

  const prompt = `
  Search for the latest statistical data about ${topic}.
  Then analyze the data using Python code and create visualizations.
  `;

  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: [prompt],
    config: {
      tools: [{ googleSearch: {} }, { codeExecution: {} }],
    },
  });

  return response;
}
```

## Limitations

### Critical Limitations

1. **Output type**: The model can only generate and execute code. It **cannot return other artifacts** like media files (except graphs via I/O feature).

2. **Language**: Only **Python** code can be executed. Code in other languages can be generated but not run.

3. **Model variations**: There is variation in the ability of different models to use code execution successfully.

4. **Potential regressions**: In some cases, enabling code execution can lead to regressions in other areas of model output (e.g., creative writing).

5. **Library restrictions**: Cannot install custom libraries. Only pre-installed libraries are available.

6. **Runtime limit**: Maximum execution time is 30 seconds.

7. **No persistence**: No state is maintained between executions in different requests.

## Best Practices

### 1. Be Specific About Requirements

```typescript
// ‚ùå Vague
const prompt = "Calculate some statistics";

// ‚úì Specific
const prompt = `
Calculate the following statistics for this dataset:
- Mean, median, and mode
- Standard deviation
- 95th percentile
Display results in a formatted table.
`;
```

### 2. Request Error Handling in Generated Code

```typescript
const prompt = `
Calculate the factorial of the numbers in this list: [5, 10, 15, 20, 25]
Include error handling for invalid inputs.
Print results in a formatted way.
`;
```

### 3. Verify Code Execution Success

```typescript
async function safeCodeExecution(prompt: string): Promise<string> {
  const ai = new GoogleGenAI({});

  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: [prompt],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  const parts = response.candidates?.[0]?.content?.parts || [];

  // Check if code execution was successful
  const executionResult = parts.find((part) => part.codeExecutionResult);

  if (executionResult) {
    if (executionResult.codeExecutionResult?.outcome === "OUTCOME_OK") {
      console.log("‚úì Code executed successfully");
    } else if (
      executionResult.codeExecutionResult?.outcome === "OUTCOME_FAILED"
    ) {
      console.error("‚úó Code execution failed");
      console.error("Error:", executionResult.codeExecutionResult.output);
      throw new Error("Code execution failed");
    } else if (
      executionResult.codeExecutionResult?.outcome ===
      "OUTCOME_DEADLINE_EXCEEDED"
    ) {
      console.error("‚è±Ô∏è Code execution timeout");
      throw new Error("Code execution exceeded 30 second limit");
    }
  }

  return response.text;
}
```

### 4. Monitor Token Usage

```typescript
function logCodeExecutionUsage(response: CodeExecutionResponse): void {
  const usage = response.usageMetadata;

  if (!usage) {
    return;
  }

  console.log("\nüìä Token Usage:");
  console.log(`  Prompt: ${usage.promptTokenCount}`);

  if (usage.intermediateTokenCount) {
    console.log(
      `  Intermediate (code execution): ${usage.intermediateTokenCount}`,
    );
    console.log(
      `  Total input: ${usage.promptTokenCount + usage.intermediateTokenCount}`,
    );
  }

  console.log(`  Output: ${usage.candidatesTokenCount}`);
  console.log(`  Total: ${usage.totalTokenCount}`);
}
```

### 5. Request Visualizations Explicitly

```typescript
const prompt = `
Analyze this data and create the following visualizations using matplotlib:
1. Line chart showing the trend over time
2. Bar chart comparing categories
3. Histogram of the distribution

Make sure the charts have proper labels, titles, and legends.
`;
```

### 6. Break Complex Tasks into Steps

```typescript
const chat = ai.chats.create({
  model: "gemini-2.5-flash",
  config: {
    tools: [{ codeExecution: {} }],
  },
});

// Step 1: Load and explore data
await chat.sendMessage({
  message: "First, load the data and show basic statistics",
});

// Step 2: Clean data
await chat.sendMessage({
  message:
    "Now clean the data by removing outliers and handling missing values",
});

// Step 3: Analyze
await chat.sendMessage({
  message: "Perform correlation analysis and create a heatmap",
});

// Step 4: Visualize
await chat.sendMessage({
  message: "Create final visualizations showing the key insights",
});
```

## Complete Examples

### Example 1: Data Analysis with Visualization

```typescript
import { GoogleGenAI } from "@google/genai";
import { writeFileSync } from "fs";

interface DataAnalysisResult {
  summary: string;
  code: string[];
  results: string[];
  graphs: number;
}

async function performDataAnalysis(
  csvData: string,
): Promise<DataAnalysisResult> {
  const ai = new GoogleGenAI({});

  const base64Data = Buffer.from(csvData).toString("base64");

  const prompt = `
  Analyze this CSV data and provide:
  1. Summary statistics (mean, median, std dev)
  2. Correlation analysis
  3. Visualizations:
     - Distribution histogram
     - Correlation heatmap
     - Trend line chart
  
  Use matplotlib for all visualizations with proper labels and styling.
  `;

  const response = await ai.models.generateContent({
    model: "gemini-2.0-flash",
    contents: [
      {
        parts: [
          { text: prompt },
          {
            inlineData: {
              mimeType: "text/csv",
              data: base64Data,
            },
          },
        ],
      },
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  const parts = extractCodeExecutionParts(response);

  // Save generated graphs
  parts.images.forEach((image, index) => {
    writeFileSync(
      `output_graph_${index + 1}.png`,
      Buffer.from(image.data, "base64"),
    );
  });

  return {
    summary: response.text,
    code: parts.code,
    results: parts.results,
    graphs: parts.images.length,
  };
}

// Usage
const csvData = `
date,revenue,users
2024-01-01,50000,1000
2024-02-01,55000,1100
2024-03-01,60000,1200
`;

const analysis = await performDataAnalysis(csvData);
console.log(analysis.summary);
console.log(`Generated ${analysis.graphs} visualization(s)`);
```

### Example 2: Mathematical Problem Solving

```typescript
import { GoogleGenAI } from "@google/genai";

async function solveMathProblem(problem: string): Promise<{
  solution: string;
  steps: string[];
  code: string;
  result: string;
}> {
  const ai = new GoogleGenAI({});

  const prompt = `
  Solve this mathematical problem step by step:
  ${problem}
  
  Show your working, generate Python code to verify the solution,
  and explain the final answer.
  `;

  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: [prompt],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  const parts = extractCodeExecutionParts(response);

  return {
    solution: response.text,
    steps: parts.explanation,
    code: parts.code.join("\n"),
    result: parts.results.join("\n"),
  };
}

// Usage
const problem = `
Find the area under the curve y = x^2 from x = 0 to x = 5
using numerical integration.
`;

const solution = await solveMathProblem(problem);
console.log("üìù Solution:", solution.solution);
console.log("\nüíª Code used:", solution.code);
console.log("\nüìä Result:", solution.result);
```

### Example 3: Combining Search and Code Execution

```typescript
import { GoogleGenAI } from "@google/genai";

async function analyzeRealTimeData(query: string) {
  const ai = new GoogleGenAI({});

  const prompt = `
  ${query}
  
  First, search for the latest data, then:
  1. Extract numerical values
  2. Perform statistical analysis
  3. Create visualizations
  4. Provide insights
  `;

  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: [prompt],
    config: {
      tools: [{ googleSearch: {} }, { codeExecution: {} }],
    },
  });

  // Check what data sources were used
  const groundingMeta = response.candidates?.[0]?.groundingMetadata;
  if (groundingMeta) {
    console.log("üîç Search queries:", groundingMeta.webSearchQueries);
  }

  // Check code execution
  checkCodeExecutionStatus(response);

  return response.text;
}

// Usage
const result = await analyzeRealTimeData(
  "What are the current unemployment rates across major economies? " +
    "Analyze trends and create comparison charts.",
);
console.log(result);
```

### Example 4: Scientific Computing

```typescript
import { GoogleGenAI } from "@google/genai";

async function simulatePhysics(scenario: string) {
  const ai = new GoogleGenAI({});

  const prompt = `
  ${scenario}
  
  Use Python with numpy, scipy, and matplotlib to:
  1. Set up the equations
  2. Run the simulation
  3. Visualize the results with clear labels
  4. Explain the physical interpretation
  `;

  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: [prompt],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  const parts = extractCodeExecutionParts(response);

  return {
    explanation: parts.explanation.join("\n"),
    simulation: parts.results.join("\n"),
    visualizations: parts.images.length,
  };
}

// Usage
const scenario = `
Simulate projectile motion with air resistance for an object:
- Initial velocity: 50 m/s at 45 degrees
- Mass: 1 kg
- Drag coefficient: 0.47
- Time duration: 5 seconds
Plot the trajectory and compare with no air resistance case.
`;

const simulation = await simulatePhysics(scenario);
console.log(simulation.explanation);
```

### Example 5: Text Processing and Analysis

```typescript
import { GoogleGenAI } from "@google/genai";

async function analyzeText(text: string, analysisType: string) {
  const ai = new GoogleGenAI({});

  const prompt = `
  Perform ${analysisType} on this text:
  "${text}"
  
  Use Python with appropriate libraries (pandas, numpy, etc.) to:
  1. Tokenize and process the text
  2. Calculate relevant statistics
  3. Create visualizations if applicable
  4. Provide insights
  `;

  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: [prompt],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  return extractCodeExecutionParts(response);
}

// Usage
const text = `
To be or not to be, that is the question.
Whether 'tis nobler in the mind to suffer
The slings and arrows of outrageous fortune,
Or to take arms against a sea of troubles.
`;

const analysis = await analyzeText(
  text,
  "word frequency analysis and sentiment",
);
console.log("Results:", analysis.results.join("\n"));
```

## Error Handling

### Comprehensive Error Handler

```typescript
class CodeExecutionError extends Error {
  constructor(
    message: string,
    public outcome?: string,
    public output?: string,
  ) {
    super(message);
    this.name = "CodeExecutionError";
  }
}

async function robustCodeExecution(prompt: string): Promise<string> {
  const ai = new GoogleGenAI({});

  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: [prompt],
      config: {
        tools: [{ codeExecution: {} }],
      },
    });

    // Verify code execution
    const parts = response.candidates?.[0]?.content?.parts || [];
    const executionResult = parts.find((part) => part.codeExecutionResult);

    if (executionResult) {
      const result = executionResult.codeExecutionResult!;

      if (result.outcome === "OUTCOME_FAILED") {
        throw new CodeExecutionError(
          "Code execution failed",
          result.outcome,
          result.output,
        );
      } else if (result.outcome === "OUTCOME_DEADLINE_EXCEEDED") {
        throw new CodeExecutionError(
          "Code execution timeout (>30s)",
          result.outcome,
          result.output,
        );
      }
    }

    return response.text;
  } catch (error) {
    if (error instanceof CodeExecutionError) {
      console.error(`‚ùå ${error.message}`);
      console.error(`Outcome: ${error.outcome}`);
      console.error(`Output: ${error.output}`);

      // Attempt simpler version
      console.log("Retrying with simplified prompt...");
      const simplifiedPrompt = `${prompt}\n\nUse a simple, straightforward approach.`;

      try {
        const retryResponse = await ai.models.generateContent({
          model: "gemini-2.5-flash",
          contents: [simplifiedPrompt],
          config: {
            tools: [{ codeExecution: {} }],
          },
        });

        return retryResponse.text;
      } catch (retryError) {
        console.error("Retry also failed");
        throw retryError;
      }
    }

    throw error;
  }
}
```

## Summary

Code execution transforms Gemini into a powerful computational tool that can:

- Generate and execute Python code to solve problems
- Perform complex mathematical calculations
- Analyze data and create visualizations
- Leverage scientific computing libraries
- Combine with search for real-time data analysis

Key considerations for production use:

- Monitor token usage (intermediate tokens add to input costs)
- Handle execution failures gracefully (30-second timeout, up to 5 retries)
- Only Python is supported for execution
- Cannot install custom libraries
- Matplotlib is the only supported graphing library
- Starting with Gemini 2.0 Flash, file I/O is supported for enhanced capabilities

By combining TypeScript's type safety with Gemini's code execution capabilities, you can build sophisticated analytical applications that bridge natural language understanding with computational power.
